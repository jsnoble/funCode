{"version":3,"sources":["/home/jared/Desktop/funCode/node_modules/acorn/src/parseutil.js"],"names":[],"mappings":"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","file":"parseutil-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak} from \"./whitespace\"\n\nconst pp = Parser.prototype\n\n// ## Parser utilities\n\n// Test whether a statement node is the string literal `\"use strict\"`.\n\npp.isUseStrict = function(stmt) {\n  return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n    stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\"\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n"]}