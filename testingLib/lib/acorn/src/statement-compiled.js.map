{"version":3,"sources":["/home/jared/Desktop/funCode/node_modules/acorn/src/statement.js"],"names":[],"mappings":"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","file":"statement-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak} from \"./whitespace\"\n\nconst pp = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp.parseTopLevel = function(node) {\n  let first = true\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    let stmt = this.parseStatement(true, true)\n    node.body.push(stmt)\n    if (first && this.isUseStrict(stmt)) this.setStrict(true)\n    first = false\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nconst loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp.parseStatement = function(declaration, topLevel) {\n  let starttype = this.type, node = this.startNode()\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._let: case tt._const: if (!declaration) this.unexpected() // NOTE: falls through to _var\n  case tt._var: return this.parseVarStatement(node, starttype)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    let maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp.parseBreakContinueStatement = function(node, keyword) {\n  let isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    let lab = this.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  if (this.type === tt._var || this.type === tt._let || this.type === tt._const) {\n    let init = this.startNode(), varKind = this.type\n    this.next()\n    this.parseVar(init, true, varKind)\n    this.finishNode(init, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init.declarations.length === 1 &&\n        !(varKind !== tt._var && init.declarations[0].init))\n      return this.parseForIn(node, init)\n    return this.parseFor(node, init)\n  }\n  let refShorthandDefaultPos = {start: 0}\n  let init = this.parseExpression(true, refShorthandDefaultPos)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    return this.parseForIn(node, init)\n  } else if (refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start)\n  }\n  return this.parseFor(node, init)\n}\n\npp.parseFunctionStatement = function(node) {\n  this.next()\n  return this.parseFunction(node, true)\n}\n\npp.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  node.consequent = this.parseStatement(false)\n  node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp.parseSwitchStatement = function(node) {\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault; this.type != tt.braceR;) {\n    if (this.type === tt._case || this.type === tt._default) {\n      let isCase = this.type === tt._case\n      if (cur) this.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this.startNode())\n      cur.consequent = []\n      this.next()\n      if (isCase) {\n        cur.test = this.parseExpression()\n      } else {\n        if (sawDefault) this.raise(this.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this.expect(tt.colon)\n    } else {\n      if (!cur) this.unexpected()\n      cur.consequent.push(this.parseStatement(true))\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nconst empty = []\n\npp.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    let clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.checkLVal(clause.param, true)\n    this.expect(tt.parenR)\n    clause.guard = null\n    clause.body = this.parseBlock()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.guardedHandlers = empty\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp.parseLabeledStatement = function(node, maybeName, expr) {\n  for (let i = 0; i < this.labels.length; ++i)\n    if (this.labels[i].name === maybeName) this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  let kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  this.labels.push({name: maybeName, kind: kind})\n  node.body = this.parseStatement(true)\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp.parseBlock = function(allowStrict) {\n  let node = this.startNode(), first = true, oldStrict\n  node.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    let stmt = this.parseStatement(true)\n    node.body.push(stmt)\n    if (first && allowStrict && this.isUseStrict(stmt)) {\n      oldStrict = this.strict\n      this.setStrict(this.strict = true)\n    }\n    first = false\n  }\n  if (oldStrict === false) this.setStrict(false)\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp.parseForIn = function(node, init) {\n  let type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp.parseVar = function(node, isFor, kind) {\n  node.declarations = []\n  node.kind = kind.keyword\n  for (;;) {\n    let decl = this.startNode()\n    decl.id = this.parseBindingAtom()\n    this.checkLVal(decl.id, true)\n    if (this.eat(tt.eq)) {\n      decl.init = this.parseMaybeAssign(isFor)\n    } else if (kind === tt._const && !(this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this.type === tt._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"))\n    if (!this.eat(tt.comma)) break\n  }\n  return node\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseFunction = function(node, isStatement, allowExpressionBody) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = this.eat(tt.star)\n  if (isStatement || this.type === tt.name)\n    node.id = this.parseIdent()\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n  this.parseFunctionBody(node, allowExpressionBody)\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseClass = function(node, isStatement) {\n  this.next()\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n  let classBody = this.startNode()\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this.eat(tt.semi)) continue\n    let method = this.startNode()\n    let isGenerator = this.eat(tt.star)\n    this.parsePropertyName(method)\n    if (this.type !== tt.parenL && !method.computed && method.key.type === \"Identifier\" &&\n        method.key.name === \"static\") {\n      if (isGenerator) this.unexpected()\n      method['static'] = true\n      isGenerator = this.eat(tt.star)\n      this.parsePropertyName(method)\n    } else {\n      method['static'] = false\n    }\n    method.kind = \"method\"\n    if (!method.computed && !isGenerator) {\n      if (method.key.type === \"Identifier\") {\n        if (this.type !== tt.parenL && (method.key.name === \"get\" || method.key.name === \"set\")) {\n          method.kind = method.key.name\n          this.parsePropertyName(method)\n        } else if (!method['static'] && method.key.name === \"constructor\") {\n          method.kind = \"constructor\"\n        }\n      } else if (!method['static'] && method.key.type === \"Literal\" && method.key.value === \"constructor\") {\n        method.kind = \"constructor\"\n      }\n    }\n    method.value = this.parseMethod(isGenerator)\n    classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\n// Parses module export declaration.\n\npp.parseExport = function(node) {\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    let expr = this.parseMaybeAssign()\n    let needsSemi = true\n    if (expr.type == \"FunctionExpression\" ||\n        expr.type == \"ClassExpression\") {\n      needsSemi = false\n      if (expr.id) {\n        expr.type = expr.type == \"FunctionExpression\"\n          ? \"FunctionDeclaration\"\n          : \"ClassDeclaration\"\n      }\n    }\n    node.declaration = expr\n    if (needsSemi) this.semicolon()\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.type.keyword) {\n    node.declaration = this.parseStatement(true)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers()\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\n// Parses a comma-separated list of module exports.\n\npp.parseExportSpecifiers = function() {\n  let nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.local = this.parseIdent(this.type === tt._default)\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n    node.kind = \"\"\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp.parseImportSpecifiers = function() {\n  let nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    let node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    let node = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.imported = this.parseIdent(true)\n    node.local = this.eatContextual(\"as\") ? this.parseIdent() : node.imported\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n"]}