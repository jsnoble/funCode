{"version":3,"sources":["/home/jared/Desktop/funCode/node_modules/acorn/src/expression.js"],"names":[],"mappings":"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","file":"expression-compiled.js","sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {reservedWords} from \"./identifier\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6) return\n  let key = prop.key, name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  let kind = prop.kind || \"init\", other\n  if (has(propHash, name)) {\n    other = propHash[name]\n    let isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raise(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function(noIn, refShorthandDefaultPos) {\n  let start = this.markPosition()\n  let expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos)\n  if (this.type === tt.comma) {\n    let node = this.startNodeAt(start)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function(noIn, refShorthandDefaultPos) {\n  if (this.type == tt._yield && this.inGenerator) return this.parseYield()\n\n  let failOnShorthandAssign\n  if (!refShorthandDefaultPos) {\n    refShorthandDefaultPos = {start: 0}\n    failOnShorthandAssign = true\n  } else {\n    failOnShorthandAssign = false\n  }\n  let start = this.markPosition()\n  let left = this.parseMaybeConditional(noIn, refShorthandDefaultPos)\n  if (this.type.isAssign) {\n    let node = this.startNodeAt(start)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start)\n  }\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function(noIn, refShorthandDefaultPos) {\n  let start = this.markPosition()\n  let expr = this.parseExprOps(noIn, refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  if (this.eat(tt.question)) {\n    let node = this.startNodeAt(start)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp.parseExprOps = function(noIn, refShorthandDefaultPos) {\n  let start = this.markPosition()\n  let expr = this.parseMaybeUnary(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  return this.parseExprOp(expr, start, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function(left, leftStart, minPrec, noIn) {\n  let prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      let node = this.startNodeAt(leftStart)\n      node.left = left\n      node.operator = this.value\n      let op = this.type\n      this.next()\n      let start = this.markPosition()\n      node.right = this.parseExprOp(this.parseMaybeUnary(), start, prec, noIn)\n      this.finishNode(node, (op === tt.logicalOR || op === tt.logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\")\n      return this.parseExprOp(node, leftStart, minPrec, noIn)\n    }\n  }\n  return left\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function(refShorthandDefaultPos) {\n  if (this.type.prefix) {\n    let node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary()\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raise(node.start, \"Deleting local variable in strict mode\")\n    return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  }\n  let start = this.markPosition()\n  let expr = this.parseExprSubscripts(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  while (this.type.postfix && !this.canInsertSemicolon()) {\n    let node = this.startNodeAt(start)\n    node.operator = this.value\n    node.prefix = false\n    node.argument = expr\n    this.checkLVal(expr)\n    this.next()\n    expr = this.finishNode(node, \"UpdateExpression\")\n  }\n  return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function(refShorthandDefaultPos) {\n  let start = this.markPosition()\n  let expr = this.parseExprAtom(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  return this.parseSubscripts(expr, start)\n}\n\npp.parseSubscripts = function(base, start, noCalls) {\n  if (this.eat(tt.dot)) {\n    let node = this.startNodeAt(start)\n    node.object = base\n    node.property = this.parseIdent(true)\n    node.computed = false\n    return this.parseSubscripts(this.finishNode(node, \"MemberExpression\"), start, noCalls)\n  } else if (this.eat(tt.bracketL)) {\n    let node = this.startNodeAt(start)\n    node.object = base\n    node.property = this.parseExpression()\n    node.computed = true\n    this.expect(tt.bracketR)\n    return this.parseSubscripts(this.finishNode(node, \"MemberExpression\"), start, noCalls)\n  } else if (!noCalls && this.eat(tt.parenL)) {\n    let node = this.startNodeAt(start)\n    node.callee = base\n    node.arguments = this.parseExprList(tt.parenR, false)\n    return this.parseSubscripts(this.finishNode(node, \"CallExpression\"), start, noCalls)\n  } else if (this.type === tt.backQuote) {\n    let node = this.startNodeAt(start)\n    node.tag = base\n    node.quasi = this.parseTemplate()\n    return this.parseSubscripts(this.finishNode(node, \"TaggedTemplateExpression\"), start, noCalls)\n  } return base\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function(refShorthandDefaultPos) {\n  let node\n  switch (this.type) {\n  case tt._this:\n  case tt._super:\n    let type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt._yield:\n    if (this.inGenerator) this.unexpected()\n\n  case tt.name:\n    let start = this.markPosition()\n    let id = this.parseIdent(this.type !== tt.name)\n    if (!this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      return this.parseArrowExpression(this.startNodeAt(start), [id])\n    }\n    return id\n\n  case tt.regexp:\n    let value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    return this.parseParenAndDistinguishExpression()\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    // check whether this is array comprehension or regular array\n    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {\n      return this.parseComprehension(node, false)\n    }\n    node.elements = this.parseExprList(tt.bracketR, true, true, refShorthandDefaultPos)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refShorthandDefaultPos)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseLiteral = function(value) {\n  let node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  let val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp.parseParenAndDistinguishExpression = function() {\n  let start = this.markPosition(), val\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {\n      return this.parseComprehension(this.startNodeAt(start), true)\n    }\n\n    let innerStart = this.markPosition(), exprList = [], first = true\n    let refShorthandDefaultPos = {start: 0}, spreadStart, innerParenStart\n    while (this.type !== tt.parenR) {\n      first ? first = false : this.expect(tt.comma)\n      if (this.type === tt.ellipsis) {\n        spreadStart = this.start\n        exprList.push(this.parseRest())\n        break\n      } else {\n        if (this.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this.start\n        }\n        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos))\n      }\n    }\n    let innerEnd = this.markPosition()\n    this.expect(tt.parenR)\n\n    if (!this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      if (innerParenStart) this.unexpected(innerParenStart)\n      return this.parseArrowExpression(this.startNodeAt(start), exprList)\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start)\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStart)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEnd)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    let par = this.startNodeAt(start)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument\n// to be a `[]` or dot subscript expression, but not a call — at\n// least, not without wrapping it in parentheses. Thus, it uses the\n\nconst empty = []\n\npp.parseNew = function() {\n  let node = this.startNode()\n  let meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raise(node.property.start, \"The only valid meta property for new is new.target\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  let start = this.markPosition()\n  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)\n  else node.arguments = empty\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp.parseTemplateElement = function() {\n  let elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp.parseTemplate = function() {\n  let node = this.startNode()\n  this.next()\n  node.expressions = []\n  let curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this.expect(tt.dollarBraceL)\n    node.expressions.push(this.parseExpression())\n    this.expect(tt.braceR)\n    node.quasis.push(curElt = this.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function(isPattern, refShorthandDefaultPos) {\n  let node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let prop = this.startNode(), isGenerator, start\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refShorthandDefaultPos)\n        start = this.markPosition()\n      if (!isPattern)\n        isGenerator = this.eat(tt.star)\n    }\n    this.parsePropertyName(prop)\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault() : this.parseMaybeAssign(false, refShorthandDefaultPos)\n      prop.kind = \"init\"\n    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n      if (isPattern) this.unexpected()\n      prop.kind = \"init\"\n      prop.method = true\n      prop.value = this.parseMethod(isGenerator)\n    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type != tt.comma && this.type != tt.braceR)) {\n      if (isGenerator || isPattern) this.unexpected()\n      prop.kind = prop.key.name\n      this.parsePropertyName(prop)\n      prop.value = this.parseMethod(false)\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      prop.kind = \"init\"\n      if (isPattern) {\n        if (this.isKeyword(prop.key.name) ||\n            (this.strict && (reservedWords.strictBind(prop.key.name) || reservedWords.strict(prop.key.name))) ||\n            (!this.options.allowReserved && this.isReservedWord(prop.key.name)))\n          this.raise(prop.key.start, \"Binding \" + prop.key.name)\n        prop.value = this.parseMaybeDefault(start, prop.key)\n      } else if (this.type === tt.eq && refShorthandDefaultPos) {\n        if (!refShorthandDefaultPos.start)\n          refShorthandDefaultPos.start = this.start\n        prop.value = this.parseMaybeDefault(start, prop.key)\n      } else {\n        prop.value = prop.key\n      }\n      prop.shorthand = true\n    } else this.unexpected()\n\n    this.checkPropClash(prop, propHash)\n    node.properties.push(this.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return\n    } else {\n      prop.computed = false\n    }\n  }\n  prop.key = (this.type === tt.num || this.type === tt.string) ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n}\n\n// Parse object or class method.\n\npp.parseMethod = function(isGenerator) {\n  let node = this.startNode()\n  this.initFunction(node)\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n  let allowExpressionBody\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = isGenerator\n    allowExpressionBody = true\n  } else {\n    allowExpressionBody = false\n  }\n  this.parseFunctionBody(node, allowExpressionBody)\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function(node, params) {\n  this.initFunction(node)\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function(node, allowExpression) {\n  let isExpression = allowExpression && this.type !== tt.braceL\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    let oldInFunc = this.inFunction, oldInGen = this.inGenerator, oldLabels = this.labels\n    this.inFunction = true; this.inGenerator = node.generator; this.labels = []\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.inFunction = oldInFunc; this.inGenerator = oldInGen; this.labels = oldLabels\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {\n    let nameHash = {}, oldStrict = this.strict\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    for (let i = 0; i < node.params.length; i++)\n      this.checkLVal(node.params[i], true, nameHash)\n    this.strict = oldStrict\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function(close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (allowTrailingComma && this.afterTrailingComma(close)) break\n    } else first = false\n\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else {\n      if (this.type === tt.ellipsis)\n        elts.push(this.parseSpread(refShorthandDefaultPos))\n      else\n        elts.push(this.parseMaybeAssign(false, refShorthandDefaultPos))\n    }\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function(liberal) {\n  let node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal &&\n        ((!this.options.allowReserved && this.isReservedWord(this.value)) ||\n         (this.strict && reservedWords.strict(this.value)) &&\n         (this.options.ecmaVersion >= 6 || \n          this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1)))\n      this.raise(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp.parseYield = function() {\n  let node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\n// Parses array and generator comprehensions.\n\npp.parseComprehension = function(node, isGenerator) {\n  node.blocks = []\n  while (this.type === tt._for) {\n    let block = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    block.left = this.parseBindingAtom()\n    this.checkLVal(block.left, true)\n    this.expectContextual(\"of\")\n    block.right = this.parseExpression()\n    this.expect(tt.parenR)\n    node.blocks.push(this.finishNode(block, \"ComprehensionBlock\"))\n  }\n  node.filter = this.eat(tt._if) ? this.parseParenExpression() : null\n  node.body = this.parseExpression()\n  this.expect(isGenerator ? tt.parenR : tt.bracketR)\n  node.generator = isGenerator\n  return this.finishNode(node, \"ComprehensionExpression\")\n}\n"]}